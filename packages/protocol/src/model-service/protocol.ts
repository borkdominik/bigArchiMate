import * as rpc from 'vscode-jsonrpc/node';
import { ElementType, RelationType } from '../glsp/types';

export const ArchiMateLanguageRegex = {
   STRING: /^"[^"]*"$|^'[^']*'$/,
   NUMBER: /^(-)?[0-9]+(\.[0-9]*)?$/,
   SL_COMMENT: /^#[^\n\r]*$/,
   ID: /^[_a-zA-Z][\w_\-~$#@/\d$]*$/
};

/**
 * Serialized version of the semantic model generated by Langium.
 */

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type Reference<T> = string;

export interface ArchiMateObject {
   readonly $type: string;
}

export interface Identifiable {
   id: string;
   $globalId: string;
}

export interface WithCustomProperties {
   customProperties?: Array<CustomProperty>;
}

export interface CustomProperty {
   name: string;
   value?: string;
}

export interface ArchiMateDocument<T = ArchiMateRoot, D = ModelDiagnostic> {
   uri: string;
   root: T;
   diagnostics: D[];
}

export interface ArchiMateRoot extends ArchiMateObject {
   readonly $type: 'ArchiMateRoot';
   element?: Element;
   relation?: Relation;
   junction?: Junction;
}

export function isArchiMateRoot(model?: any): model is ArchiMateRoot {
   return !!model && model.$type === 'ArchiMateRoot';
}

export const PropertyType = 'Property';

export interface Property extends ArchiMateObject, Identifiable {
   readonly $type: typeof PropertyType;
   value?: string;
   name?: string;
}

export interface Element extends ArchiMateObject, Identifiable {
   readonly $type: 'Element';
   name?: string;
   documentation?: string;
   type: ElementType;
   properties: Array<Property>;
}

export interface Junction extends ArchiMateObject, Identifiable {
   readonly $type: 'Junction';
   name?: string;
   documentation?: string;
   properties: Array<Property>;
}

export interface Relation extends ArchiMateObject, Identifiable {
   readonly $type: 'Relation';
   name?: string;
   documentation?: string;
   type: RelationType;
   source: Reference<Element>;
   target: Reference<Element>;
   properties: Array<Property>;
}

export interface ClientModelArgs {
   uri: string;
   clientId: string;
}

export interface OpenModelArgs extends ClientModelArgs {
   languageId?: string;
   version?: number;
}

export interface CloseModelArgs extends ClientModelArgs {}

export interface UpdateModelArgs<T = ArchiMateRoot> extends ClientModelArgs {
   model: T | string;
}

export interface SaveModelArgs<T = ArchiMateRoot> extends ClientModelArgs {
   model: T | string;
}

export interface ModelDiagnostic {
   type: 'lexing-error' | 'parsing-error' | 'validation-error';
   message: string;
   severity: 'error' | 'warning' | 'info';
}

export namespace ModelDiagnostic {
   export function isError(diagnostic: ModelDiagnostic): boolean {
      return diagnostic.severity === 'error';
   }

   export function errors(diagnostics: ModelDiagnostic[]): ModelDiagnostic[] {
      return diagnostics.filter(isError);
   }

   export function hasErrors(diagnostics: ModelDiagnostic[]): boolean {
      return diagnostics.some(isError);
   }
}

export interface ModelUpdatedEvent<D = ArchiMateDocument> {
   document: D;
   sourceClientId: string;
   reason: 'changed' | 'deleted' | 'updated' | 'saved';
}

export interface ModelSavedEvent<D = ArchiMateDocument> {
   document: D;
   sourceClientId: string;
}

/**
 * A context to describe a cross reference to retrieve reachable elements.
 */
export interface CrossReferenceContext {
   /**
    * The container from which we want to query the reachable elements.
    */
   container: CrossReferenceContainer;
   /**
    * Synthetic elements starting from the container to further narrow down the cross reference.
    * This is useful for elements that are being created or if the element cannot be identified.
    */
   syntheticElements?: SyntheticElement[];
   /**
    * The property of the element referenced through the source container and the optional synthetic
    * elements for which we should retrieve the reachable elements.
    */
   property: string;
}
export interface RootElementReference {
   uri: string;
}
export function isRootElementReference(object: unknown): object is RootElementReference {
   return !!object && typeof object === 'object' && 'uri' in object && typeof object.uri === 'string';
}
export interface GlobalElementReference {
   globalId: string;
   type?: string;
}
export function isGlobalElementReference(object: unknown): object is GlobalElementReference {
   return !!object && typeof object === 'object' && 'globalId' in object && typeof object.globalId === 'string';
}
export interface SyntheticDocument {
   uri: string;
   type: string;
}
export function isSyntheticDocument(object: unknown): object is SyntheticDocument {
   return (
      !!object &&
      typeof object === 'object' &&
      'uri' in object &&
      typeof object.uri === 'string' &&
      'type' in object &&
      typeof object.type === 'string'
   );
}
export type CrossReferenceContainer = RootElementReference | GlobalElementReference | SyntheticDocument;

export interface SyntheticElement {
   type: string;
   property: string;
}
export function isSyntheticElement(object: unknown): object is SyntheticElement {
   return (
      !!object &&
      typeof object === 'object' &&
      'type' in object &&
      typeof object.type === 'string' &&
      'property' in object &&
      typeof object.property === 'string'
   );
}
export interface ReferenceableElement {
   uri: string;
   type: string;
   label: string;
}

export interface CrossReference {
   /**
    * The container from which we want to resolve the reference.
    */
   container: CrossReferenceContainer;
   /**
    * The property for which we want to resolve the reference.
    */
   property: string;
   /**
    * The textual value of the reference we are resolving.
    */
   value: string;
}

export interface ResolvedElement {
   uri: string;
   model: ArchiMateRoot;
}

export interface SystemInfoArgs {
   contextUri: string;
}

export interface SystemInfo {
   id: string;
   name: string;
   directory: string;
   packageFilePath: string;
   modelFilePaths: string[];
}

export interface SystemUpdatedEvent {
   system: SystemInfo;
   reason: 'added' | 'removed';
}
export type SystemUpdateListener = (event: SystemUpdatedEvent) => void | Promise<void>;

export const OpenModel = new rpc.RequestType1<OpenModelArgs, ArchiMateDocument | undefined, void>('server/open');
export const CloseModel = new rpc.RequestType1<CloseModelArgs, void, void>('server/close');
export const RequestModel = new rpc.RequestType1<string, ArchiMateDocument | undefined, void>('server/request');
export const RequestModelDiagramNode = new rpc.RequestType2<string, string, Element | undefined, void>('server/requestModelDiagramNode');

export const FindReferenceableElements = new rpc.RequestType1<CrossReferenceContext, ReferenceableElement[], void>('server/complete');
export const ResolveReference = new rpc.RequestType1<CrossReference, ResolvedElement | undefined, void>('server/resolve');

export const UpdateModel = new rpc.RequestType1<UpdateModelArgs, ArchiMateDocument, void>('server/update');
export const SaveModel = new rpc.RequestType1<SaveModelArgs, void, void>('server/save');
export const OnModelSaved = new rpc.NotificationType1<ModelSavedEvent>('server/onSave');
export const OnModelUpdated = new rpc.NotificationType1<ModelUpdatedEvent>('server/onUpdated');

export const RequestSystemInfos = new rpc.RequestType1<void, SystemInfo[], void>('server/systems');
export const RequestSystemInfo = new rpc.RequestType1<SystemInfoArgs, SystemInfo | undefined, void>('server/system');
export const OnSystemsUpdated = new rpc.NotificationType1<SystemUpdatedEvent>('server/onSystemsUpdated');
